interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

"""GraphQL representation of BigInt"""
scalar BigInt

type Block implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  block: Int!
  executedAt: DateTime!
  network: Network!
  membershipregisteredAtBlock: [Membership!]
}

type BlockConnection {
  totalCount: Int!
  edges: [BlockEdge!]!
  pageInfo: PageInfo!
}

input BlockCreateInput {
  block: Float!
  executedAt: DateTime!
  network: Network!
}

type BlockEdge {
  node: Block!
  cursor: String!
}

enum BlockOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  block_ASC
  block_DESC
  executedAt_ASC
  executedAt_DESC
  network_ASC
  network_DESC
}

input BlockUpdateInput {
  block: Float
  executedAt: DateTime
  network: Network
}

input BlockWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  block_eq: Int
  block_gt: Int
  block_gte: Int
  block_lt: Int
  block_lte: Int
  block_in: [Int!]
  executedAt_eq: DateTime
  executedAt_lt: DateTime
  executedAt_lte: DateTime
  executedAt_gt: DateTime
  executedAt_gte: DateTime
  network_eq: Network
  network_in: [Network!]
}

input BlockWhereUniqueInput {
  id: ID!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type MembersByHandleFTSOutput {
  item: MembersByHandleSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union MembersByHandleSearchResult = Membership

"""Stored information about a registered user"""
type Membership implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The unique handle chosen by member"""
  handle: String!

  """Member's name"""
  name: String

  """A Url to member's Avatar image"""
  avatarUri: String

  """Short text chosen by member to share information about themselves"""
  about: String

  """Member's controller account id"""
  controllerAccount: String!

  """Member's root account id"""
  rootAccount: String!
  registeredAtBlock: Block!
  registeredAtBlockId: String!

  """Timestamp when member was registered"""
  registeredAtTime: DateTime!

  """How the member was registered"""
  entry: MembershipEntryMethod!

  """Whether member has been verified by membership working group."""
  isVerified: Boolean!

  """Whether member has been verified by membership working group."""
  isFoundingMember: Boolean!

  """Staking accounts bounded to membership."""
  boundAccounts: [String!]!

  """Current count of invites left to send."""
  inviteCount: Int!
  invitees: [Membership!]!
  invitedBy: Membership
  invitedById: String
  referredMembers: [Membership!]!
  referredBy: Membership
  referredById: String
}

type MembershipConnection {
  totalCount: Int!
  edges: [MembershipEdge!]!
  pageInfo: PageInfo!
}

input MembershipCreateInput {
  handle: String!
  name: String
  avatarUri: String
  about: String
  controllerAccount: String!
  rootAccount: String!
  registeredAtBlockId: ID!
  registeredAtTime: DateTime!
  entry: MembershipEntryMethod!
  isVerified: Boolean!
  boundAccounts: [String!]!
  inviteCount: Float!
  invitedById: ID
  referredById: ID
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipEntryMethod {
  PAID
  INVITED
  GENESIS
}

enum MembershipOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  handle_ASC
  handle_DESC
  name_ASC
  name_DESC
  avatarUri_ASC
  avatarUri_DESC
  about_ASC
  about_DESC
  controllerAccount_ASC
  controllerAccount_DESC
  rootAccount_ASC
  rootAccount_DESC
  registeredAtBlockId_ASC
  registeredAtBlockId_DESC
  registeredAtTime_ASC
  registeredAtTime_DESC
  entry_ASC
  entry_DESC
  isVerified_ASC
  isVerified_DESC
  inviteCount_ASC
  inviteCount_DESC
  invitedById_ASC
  invitedById_DESC
  referredById_ASC
  referredById_DESC
}

type MembershipSystem implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Initial invitation count of a new member."""
  defaultInviteCount: Int!

  """Current price to buy a membership."""
  membershipPrice: BigInt!

  """Amount of tokens diverted to invitor."""
  referralCut: BigInt!

  """
  The initial, locked, balance credited to controller account of invitee.
  """
  invitedInitialBalance: BigInt!
}

type MembershipSystemConnection {
  totalCount: Int!
  edges: [MembershipSystemEdge!]!
  pageInfo: PageInfo!
}

input MembershipSystemCreateInput {
  defaultInviteCount: Float!
  membershipPrice: BigInt!
  referralCut: BigInt!
  invitedInitialBalance: BigInt!
}

type MembershipSystemEdge {
  node: MembershipSystem!
  cursor: String!
}

enum MembershipSystemOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  defaultInviteCount_ASC
  defaultInviteCount_DESC
  membershipPrice_ASC
  membershipPrice_DESC
  referralCut_ASC
  referralCut_DESC
  invitedInitialBalance_ASC
  invitedInitialBalance_DESC
}

input MembershipSystemUpdateInput {
  defaultInviteCount: Float
  membershipPrice: BigInt
  referralCut: BigInt
  invitedInitialBalance: BigInt
}

input MembershipSystemWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  defaultInviteCount_eq: Int
  defaultInviteCount_gt: Int
  defaultInviteCount_gte: Int
  defaultInviteCount_lt: Int
  defaultInviteCount_lte: Int
  defaultInviteCount_in: [Int!]
  membershipPrice_eq: BigInt
  membershipPrice_gt: BigInt
  membershipPrice_gte: BigInt
  membershipPrice_lt: BigInt
  membershipPrice_lte: BigInt
  membershipPrice_in: [BigInt!]
  referralCut_eq: BigInt
  referralCut_gt: BigInt
  referralCut_gte: BigInt
  referralCut_lt: BigInt
  referralCut_lte: BigInt
  referralCut_in: [BigInt!]
  invitedInitialBalance_eq: BigInt
  invitedInitialBalance_gt: BigInt
  invitedInitialBalance_gte: BigInt
  invitedInitialBalance_lt: BigInt
  invitedInitialBalance_lte: BigInt
  invitedInitialBalance_in: [BigInt!]
}

input MembershipSystemWhereUniqueInput {
  id: ID!
}

input MembershipUpdateInput {
  handle: String
  name: String
  avatarUri: String
  about: String
  controllerAccount: String
  rootAccount: String
  registeredAtBlockId: ID
  registeredAtTime: DateTime
  entry: MembershipEntryMethod
  isVerified: Boolean
  boundAccounts: [String!]
  inviteCount: Float
  invitedById: ID
  referredById: ID
}

input MembershipWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  handle_eq: String
  handle_contains: String
  handle_startsWith: String
  handle_endsWith: String
  handle_in: [String!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  avatarUri_eq: String
  avatarUri_contains: String
  avatarUri_startsWith: String
  avatarUri_endsWith: String
  avatarUri_in: [String!]
  about_eq: String
  about_contains: String
  about_startsWith: String
  about_endsWith: String
  about_in: [String!]
  controllerAccount_eq: String
  controllerAccount_contains: String
  controllerAccount_startsWith: String
  controllerAccount_endsWith: String
  controllerAccount_in: [String!]
  rootAccount_eq: String
  rootAccount_contains: String
  rootAccount_startsWith: String
  rootAccount_endsWith: String
  rootAccount_in: [String!]
  registeredAtBlockId_eq: ID
  registeredAtBlockId_in: [ID!]
  registeredAtTime_eq: DateTime
  registeredAtTime_lt: DateTime
  registeredAtTime_lte: DateTime
  registeredAtTime_gt: DateTime
  registeredAtTime_gte: DateTime
  entry_eq: MembershipEntryMethod
  entry_in: [MembershipEntryMethod!]
  isVerified_eq: Boolean
  isVerified_in: [Boolean!]
  inviteCount_eq: Int
  inviteCount_gt: Int
  inviteCount_gte: Int
  inviteCount_lt: Int
  inviteCount_lte: Int
  inviteCount_in: [Int!]
  invitedById_eq: ID
  invitedById_in: [ID!]
  referredById_eq: ID
  referredById_in: [ID!]
}

input WorkingGroupOpeningsWhereInput {
  group_eq: ID
}

input WorkingGroupApplicationsWhereInput {
  applicant_in: [ID!]
}

input WorkersWhereInput {
  group_eq: ID
}

input WorkingGroupWhereUniqueInput {
  id: ID
}

input MembershipWhereUniqueInput {
  id: ID
  handle: String
}

enum Network {
  BABYLON
  ALEXANDRIA
  ROME
  OLYMPIA
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Query {
  blocks(offset: Int, limit: Int = 50, where: BlockWhereInput, orderBy: BlockOrderByInput): [Block!]!
  block(where: BlockWhereUniqueInput!): Block
  blocksConnection(first: Int, after: String, last: Int, before: String, where: BlockWhereInput, orderBy: BlockOrderByInput): BlockConnection!
  membershipSystems(offset: Int, limit: Int = 50, where: MembershipSystemWhereInput, orderBy: MembershipSystemOrderByInput): [MembershipSystem!]!
  membershipSystem(where: MembershipSystemWhereUniqueInput!): MembershipSystem
  membershipSystemsConnection(first: Int, after: String, last: Int, before: String, where: MembershipSystemWhereInput, orderBy: MembershipSystemOrderByInput): MembershipSystemConnection!
  memberships(offset: Int, limit: Int = 50, where: MembershipWhereInput, orderBy: MembershipOrderByInput): [Membership!]!
  membership(where: MembershipWhereUniqueInput!): Membership
  membershipsConnection(first: Int, after: String, last: Int, before: String, where: MembershipWhereInput, orderBy: MembershipOrderByInput): MembershipConnection!
  membersByHandle(whereMembership: MembershipWhereInput, skip: Int = 0, limit: Int = 5, text: String!): [MembersByHandleFTSOutput!]!
  workingGroups(offset: Int, limit: Int = 50): [WorkingGroup!]!
  workingGroup(where: WorkingGroupWhereUniqueInput!): WorkingGroup
  workers(offset: Int, limit: Int = 50, where: WorkersWhereInput): [Worker!]!
  workingGroupOpenings(offset: Int, limit: Int = 50, where: WorkingGroupOpeningsWhereInput): [WorkingGroupOpening!]
  workingGroupApplications(offset: Int, limit: Int = 50, where: WorkingGroupApplicationsWhereInput): [WorkingGroupApplication!]
}

enum EventType {
  MembershipBought,
  MemberInvited,
  MemberProfileUpdated,
  MemberAccountsUpdated,
  MemberVerificationStatusUpdated,
  ReferralCutUpdated,
  InvitesTransferred,
  MembershipPriceUpdated,
  InitialInvitationBalanceUpdated,
  LeaderInvitationQuotaUpdated,
  InitialInvitationCountUpdated,
  StakingAccountAddedEvent,
  StakingAccountConfirmed,
  StakingAccountRemoved,
}

type Event {
  "{blockNumber}-{indexInBlock}"
  id: ID!
  "Hash of the extrinsic which caused the event to be emitted"
  inExtrinsic: String
  "Blocknumber of a block in which the event was emitted."
  inBlock: Int!
  "Index of event in block from which it was emitted."
  indexInBlock: Int!
  "Type of the event"
  type: EventType!
}

interface WorkingGroupsEvent {
  "Generic event data"
  event: Event!
}

interface MembershipEvent {
  "Generic event data"
  event: Event!
}


type StandardDeleteResponse {
  id: ID!
}

type Subscription {
  stateSubscription: ProcessorState!
}

type WorkerStatusActive {
  # No additional information needed
  _phantom: Int
}

type WorkerStatusLeft {
  workerExitedEventId: ID!
}

type WorkerStatusTerminated {
  terminatedWorkerEventId: ID!
}

union WorkerStatus = WorkerStatusActive | WorkerStatusLeft | WorkerStatusTerminated

type Worker {
  "The group that the worker belongs to"
  group: WorkingGroup!
  leaderGroups: [WorkingGroup!]
  "Worker membership"
  membership: Membership!
  "Worker's role account"
  roleAccount: String!
  "Worker's reward account"
  rewardAccount: String!
  "Worker's staking account"
  stakeAccount: String!
  "Current worker status"
  status: WorkerStatus!
  "Whether the worker is also the working group lead"
  isLead: Boolean!
  "Current role stake (in JOY)"
  stake: BigInt!
  "All related reward payouts @derivedFrom(field: worker)"
  payouts: [WorkerPayoutEvent!]
  "Blocknumber of the block the worker was hired at"
  hiredAtBlock: Int!
  "Time the worker was hired at"
  hiredAtTime: DateTime!
  "Related worker entry application"
  application: WorkingGroupApplication!
  "Worker's storage data"
  storage: String
}

type WorkingGroupStatus {
  "Status name"
  name: String!
  "Status message"
  message: String
  "Status about text"
  about: String
  "Status description text"
  description: String
  "The block at which status was set"
  setAtBlock: Block!
  "The time at which status was set"
  setAtTime: DateTime!
}

type WorkingGroup {
  "Working group runtime id"
  id: ID!
  "Working group name"
  name: String!
  "Working group current status"
  status: WorkingGroupStatus
  "Current working group leader"
  leader: Worker
  "Workers that currently belong to the group or belonged to the group in the past @derivedFrom(field: group)"
  workers: [Worker!]
  "All openings related to this group @derivedFrom(field: group)"
  openings: [WorkingGroupOpening!]
  "Current working group budget (JOY)"
  budget: BigInt!
}

type OpeningStatusCancelled {
  openingCancelledEventId: ID!
}
type OpeningStatusOpen {
  # No additional information needed
  _phantom: Int
}
type OpeningStatusFilled {
  openingFilledEventId: ID!
}

union WorkingGroupOpeningStatus = OpeningStatusOpen | OpeningStatusFilled | OpeningStatusCancelled

enum WorkingGroupOpeningType {
  REGULAR
  LEADER
}

type WorkingGroupOpeningMetadata {
  "Opening short description"
  shortDescription: String!
  "Opening description (md-formatted)"
  description: String!
  "Expected max. number of applicants that will be hired"
  hiringLimit: Int!
  "Expected time when the opening will close"
  expectedEnding: DateTime!
  "Md-formatted text explaining the application process"
  applicationDetails: String!
  "List of questions that should be answered during application @derivedFrom(field: openingMetadata)"
  applicationFormQuestions: [ApplicationFormQuestion!]
}

type WorkingGroupOpening {
  "Opening runtime id"
  id: ID!
  "Related working group"
  group: WorkingGroup!
  "List of opening applications  @derivedFrom(field: opening)"
  applications: [WorkingGroupApplication!]
  "Type of the opening (Leader/Regular)"
  type: WorkingGroupOpeningType!
  "Current opening status"
  status: WorkingGroupOpeningStatus!
  "Opening metadata"
  metadata: WorkingGroupOpeningMetadata!
  "Role stake amount"
  stakeAmount: BigInt!
  "Role stake unstaking period in blocks"
  unstakingPeriod: Int!
  "Initial workers' reward per block"
  rewardPerBlock: BigInt!
  "Blocknumber of opening creation block"
  createdAtBlock: Int!
  "Time of opening creation"
  createdAtTime: DateTime!
}
type ApplicationStatusPending {
  # No additional information needed
  _phantom: Int
}
type ApplicationStatusAccepted {
  openingFilledEventId: ID!
}
type ApplicationStatusRejected {
  openingFilledEventId: ID!
}
type ApplicationStatusWithdrawn {
  applicationWithdrawnEventId: ID!
}

union WorkingGroupApplicationStatus = ApplicationStatusPending | ApplicationStatusAccepted | ApplicationStatusRejected | ApplicationStatusWithdrawn

type WorkingGroupApplication {
  "Application runtime id"
  id: ID!
  "Related working group opening"
  opening: WorkingGroupOpening!
  "Applicant's membership"
  applicant: Membership!
  "Applicant's initial role account"
  roleAccount: String!
  "Applicant's initial reward account"
  rewardAccount: String!
  "Applicant's initial staking account"
  stakingAccount: String!
  "Answers to application form questions @derivedFrom(field: application)"
  answers: [ApplicationFormQuestionAnswer!]
  "Current application status"
  status: WorkingGroupApplicationStatus!
  "Blocknumber of application creation block"
  createdAtBlock: Int!
  "Time of application creation"
  createdAtTime: DateTime!
}

type ApplicationFormQuestionAnswer {
  "Related application"
  application: WorkingGroupApplication!
  "The question beeing answered"
  question: ApplicationFormQuestion!
  "Applicant's answer"
  answer: String!
}

enum ApplicationFormQuestionType {
  TEXT
  TEXTAREA
}

type ApplicationFormQuestion {
  "Related opening metadata"
  openingMetadata: WorkingGroupOpeningMetadata!
  "The question itself"
  question: String!
  "Type of the question (UI answer input type)"
  type: ApplicationFormQuestionType!
  "Index of the question"
  index: Int!
}

type OpeningAddedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related opening"
  opening: WorkingGroupOpening!
  # Other opening data like: metadata, type, staking policy, reward etc. is immutable, so can be read directly from Opening entity
}

type AppliedOnOpeningEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related opening"
  opening: WorkingGroupOpening!
  "The application that was created"
  application: WorkingGroupApplication!
  # Same as with opening - application parameters are immutable and can be fetched from Application entity
}

type OpeningFilledEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related opening"
  opening: WorkingGroupOpening!
  # Otherwise we would need a field like "acceptedIn" filed in application or a separate table to make OneToMany
}

type LeaderSetEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related Lead worker"
  worker: Worker!
}

type WorkerRoleAccountUpdatedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "New role account"
  newRoleAccount: String!
}

type LeaderUnsetEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
}

type WorkerExitedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
}

type TerminatedWorkerEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "Slash amount (if any)"
  penalty: BigInt
  "Optional rationale"
  rationale: String
}

type TerminatedLeaderEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "Slash amount (if any)"
  penalty: BigInt
  "Optional rationale"
  rationale: String
}

type StakeSlashedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "Balance that was requested to be slashed"
  requestedAmount: BigInt!
  "Balance that was actually slashed"
  slashedAmount: BigInt!
  "Optional rationale"
  rationale: String
}

type StakeDecreasedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "The amount of JOY the stake was decreased by"
  amount: BigInt!
}

type StakeIncreasedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "The amount of JOY the stake was increased by"
  amount: BigInt!
}

type ApplicationWithdrawnEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related application"
  application: WorkingGroupApplication!
}

type OpeningCanceledEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related opening"
  opening: WorkingGroupOpening!
}

type BudgetSetEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "New working group budget"
  newBudget: BigInt!
}

type WorkerRewardAccountUpdatedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "New reward account"
  newRewardAccount: String!
}

type WorkerRewardAmountUpdatedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Related worker"
  worker: Worker!
  "New worker reward per block"
  newRewardPerBlock: BigInt!
}

type StatusTextChangedEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "New status metadata"
  status: WorkingGroupStatus!
}

type BudgetSpendingEvent implements WorkingGroupsEvent {
  "Generic event data"
  event: Event!
  "Related group"
  group: WorkingGroup!
  "Reciever account address"
  reciever: String!
  "Amount beeing spent"
  amount: BigInt!
  "Optional rationale"
  rationale: String
}

enum PayoutType {
  "Standard reward payout"
  STANDARD_REWARD
  "Return of the previously missed reward"
  RETURN_MISSED
}

type WorkerPayoutEvent {
  "Type of the worker payout"
  type: PayoutType
  "Related worker"
  worker: Worker!
  "Amount recieved"
  recieved: BigInt!
  "Amount missed (due to, for example, empty working group budget)"
  missed: BigInt!
}

